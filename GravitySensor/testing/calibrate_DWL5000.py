# -*- coding: utf-8 -*-
"""calibrate_DWL5000.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/160C2noF_r-Hnn0o1kMlorDKD9maXpSld
"""

#!/bin/env python
import sys;
import serial;
from time import sleep;
import binascii;
import struct;

def check_data(collectread):
    print('Read');
    while True :
        if ser.inWaiting() > 0 : break; 
        pass;
    read = [];
    #while True :
    for i in range(MAXLOOP) :
        sleep(stime);
        read0 = ser.readline();
        size0 = len(read0);
        print('read0 = {}'.format(read0));
        if size0>0 : 
            read0hex = ['{}'.format(hex(c)) for c in read0]; #cはread0の中のbitを10進数に直したintになっている
            #print( 'read0   ({}) = (unpack) {} / (hex) {} / (raw) {}'.format(size0, struct.unpack('{}c'.format(size0), read0), read0hex, read0 ) );
            add = read0hex ;
            read += add;
            #print('read = {}'.format(read));
            pass;
        #"""
        while len(read) > 0 :
            print('read = {}'.format(read));
            if read[0:3] == collectread : break;
            else                            : read = read[1:];
        break;
        pass;
        #"""
    if len(read) >= SIZE : break;
    pass;
    size = len(read);
    
    if size>0 : 
        readInt = [];
    for c in read : readInt.append( (int)(c,16) );
    print( 'read (hex)  ({}) = {}'.format(size, read) );
    print( 'read (int)  ({}) = {}'.format(size, readInt) );
    pass;

    return read, readInt










       
#devlocation = '/dev/tty.usbserial-AC01O8QI'; # mac
#devlocation = '/dev/ttyUSB0'; # mylinux
#devlocation = '/dev/serial/by-id/usb-FTDI_FT232R_USB_UART_AC01O8QI-if00-port0'; # tandem
#devlocation = '/dev/serial/by-id/usb-FTDI_USB_to_RS-232_422_485_Adapter_DM2CHF1B-if00-port0'; # EasySync ES-U-3001-M at tandem
#devlocation = '/dev/serial/by-id/usb-FTDI_FT232R_USB_UART_AG0JLDID-if00-port0'; # DTECH USB 2.0 TO RS422/RS485 USB converter for DWL-5000XY S/N 13B50141
#devlocation = '/dev/serial/by-id/usb-FTDI_FT232R_USB_UART_AB0L75U1-if00-port0'; # DTECH USB 2.0 TO RS422/RS485 USB converter @ Hongo
devlocation = '/dev/serial/by-id/usb-FTDI_FT232R_USB_UART_A10KEZ5G-if00-port0'; # DTECH USB 2.0 TO RS422/RS485 USB converter @ tandem
#isSingle = True;
#isSingle = False;

stime = 0.1;
#stime = 1;

BAUDRATE = 115200; # for DWL5000XY
SIZE = 12;
#SIZE = 1600000;

MAXLOOP = 10000000;




if len(sys.argv)>1 :
  isSingle = (int)(sys.argv[1]);
  print(isSingle);
  pass;

try :
  ser = serial.Serial(devlocation, 
          baudrate =BAUDRATE, 
          timeout  =0, 
          #rtscts   =False,
          #dsrdtr   =False,
          bytesize =serial.EIGHTBITS, 
          parity   =serial.PARITY_NONE, 
          stopbits =serial.STOPBITS_ONE, 
          #xonxoff  =False
          );
  while ser.read():
    print('serial open');
    pass;
  #print('serial closed');
  #ser.close();
except serial.serialutil.SerialException:
    print('exception');
    sys.exit();
#ser.rs485_mode = True;

print(ser);

ser.reset_input_buffer();
ser.reset_output_buffer();

# read input device information (for LakeShore Model 218 temperature monitor)
print('Initialization');

command=b"\x06\x24\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00";
#command=b"\x06\x24\x00\x00\x00\x00\x00\x00";

'''
for i in range(10) :
  ser.write(command);
  sleep(stime);
  pass;
#'''
ser.write(command);
sleep(stime);
while True :
  if ser.inWaiting() > 0 : break;
  pass;

print("making sure the sensor is ready for the single axis calibration mode")
command =b"\x06\x01\x0B\xA0\x00\x00\x00\x00\x00\x00\x00\x00"

ser.write(command);
sleep(stime);

(read_st1_pre, readInt_st1_pre) = check_data(["0x61","0x1B", "0x17"])

if read_st1_pre[5] == "0x01":
  print("Calibration step1 is ready.")
else:
  print("Calibration step1 is NOT ready. Forced a shotdown.")
  ser.close()
  sys.exit()

print("Locate the sensor module for position of step1.")
print("Check the position of the sensor module and perform step1 calibration?(yes/no)")
keycom = input()

if keycom == "yes":
  command =b"\x06\x01\x0B\xB0\x00\x00\x00\x00\x00\x00\x00\x00"
  ser.write(command);
  print("the step1 command was sended.")
  sleep(stime);
else:
  print("Forced a shutdown, because the response of the sensor is not correct in step1 calibration.")
  ser.close()
  sys.exit()

read_st1, readInt_st1 = check_data(["0x61","0x1B", "0x17"])
correctByte3 = ["0x17","0x16","0x15","0x14","0x13","0x12","0x11","0x10","0x0E","0x0D","0x0C","0x0B","0x0A"]

if ((read_st1[2] == "0x17") and (read_st1[3] in correctByte3) and (read_st1[5] == "0x02")):
  print("the calibration step1 is successfully done and step2 is ready.")
else:
  print("Forced a shutdown, because the response of the sensor is not correct in step1 calibration.")
  ser.close()
  sys.exit()

print("Locate the sensor module for position of step2.")
print("Check the position of the sensor module and perform step2 calibration?(yes/no)")
keycom = input()

if keycom == "yes":
  command =b"\x06\x01\x0B\xB0\x00\x00\x00\x00\x00\x00\x00\x00"
  ser.write(command);
  print("the step2 command was sended.")
  sleep(stime);
else:
  print("Forced a shutdown, because the response of the sensor is not correct in step2 calibration.")
  ser.close()
  sys.exit()




if isSingle :
  nums = [ readInt[5], readInt[4], readInt[3], readInt[2] ];
  print(readInt);
  #print(nums);
  #print( (nums[1]<<16)/1e+4 , (nums[2]<<8)/1e+4 , (nums[3])/1e+4 );
  #angleX = (nums[0]<<16) + (nums[1]<<8) + (nums[2]) ;
  angleX = (nums[0]<<24) + (nums[1]<<16) + (nums[2]<<8) + (nums[3]) ;
  angleX = (angleX - 1800000) / 10000.;
  print( 'angle X = {}'.format(angleX) );
  #temp = (nums[3]<<8) + (nums[4]) ;
  #temp = (temp - 3000.) / 100.;
  #print( 'temperature = {}'.format(temp) );
  #print( 'single axis position = {}'.format(nums[4]) );
else :
  readInt1 = readInt[2:5];
  readInt2 = readInt[5:8];
  #readInt11 = readInt1 if readInt1[-1]==10 else readInt2 ; 
  #readInt12 = readInt1 if readInt1[-1]==11 else readInt2 ; 
  readInt11 = readInt1;
  readInt12 = readInt2;
  numsX = [ readInt11[2], readInt11[1], readInt11[0] ];
  numsY = [ readInt12[2], readInt12[1], readInt12[0] ];
  print(readInt);
  print('numsX', numsX );
  print((numsX[0]<<16)/1e+4 ,(numsX[1]<<8)/1e+4 , (numsX[2])/1e+4 );
  print('numsY', numsY );
  print((numsY[0]<<16)/1e+4 ,(numsY[1]<<8)/1e+4 , (numsY[2])/1e+4 );
  angleX = (numsX[0]<<16) + (numsX[1]<<8) + (numsX[2]);
  angleX = (angleX - 300000) / 10000.;
  angleY = (numsY[0]<<16) + (numsY[1]<<8) + (numsY[2]);
  angleY = (angleY - 300000) / 10000.;
  print( 'angle X = {}'.format(angleX) );
  print( 'angle Y = {}'.format(angleY) );
  pass;

 
print('close');
ser.close();
